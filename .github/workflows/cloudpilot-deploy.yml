name: CloudPilot Deploy - small-shop-app-demo

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: false
        default: 'production'

env:
  AWS_REGION: eu-north-1
  ECR_REGISTRY: 077451504038.dkr.ecr.eu-north-1.amazonaws.com
  ECR_REPOSITORY: small-shop-app-demo
  EKS_CLUSTER_NAME: dev-cluster
  K8S_NAMESPACE: dev
  APP_NAME: small-shop-app-demo

jobs:
  build-and-deploy:
    name: Build and Deploy to AWS
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_DEFAULT_REGION }}

    - name: Verify AWS credentials
      run: |
        echo "üîç Verifying AWS credentials..."
        aws sts get-caller-identity
        echo "‚úÖ AWS credentials are working!"

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Create ECR repository if it doesn't exist
      run: |
        echo "üê≥ Checking ECR repository: $ECR_REPOSITORY"
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION
        echo "‚úÖ ECR repository ready: $ECR_REPOSITORY"

    - name: Generate image tag
      run: |
        IMAGE_TAG=$(echo ${{ github.sha }} | cut -c1-8)
        echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
        echo "üìã Generated image tag: $IMAGE_TAG"

    - name: Build Docker image
      run: |
        echo "üî® Building Docker image..."
        echo "Registry: $ECR_REGISTRY"
        echo "Repository: $ECR_REPOSITORY"
        echo "Image Tag: $IMAGE_TAG"

        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .

        echo "‚úÖ Docker image built successfully"

    - name: Push image to Amazon ECR
      run: |
        echo "üì¶ Pushing Docker image to ECR..."
        echo "Pushing: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
        echo "Pushing: $ECR_REGISTRY/$ECR_REPOSITORY:latest"

        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

        echo "‚úÖ Images pushed successfully to ECR"

    - name: Configure kubectl
      run: |
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/

        aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER_NAME

        echo "üîç Testing kubectl connection..."
        kubectl cluster-info
        kubectl get nodes

    - name: Deploy to Kubernetes
      run: |
        kubectl create namespace $K8S_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: $APP_NAME
          namespace: $K8S_NAMESPACE
          labels:
            app: $APP_NAME
            version: "$IMAGE_TAG"
            managed-by: cloudpilot
        spec:
          replicas: 1
          strategy:
            type: RollingUpdate
            rollingUpdate:
              maxSurge: 1
              maxUnavailable: 0
          progressDeadlineSeconds: 900
          selector:
            matchLabels:
              app: $APP_NAME
          template:
            metadata:
              labels:
                app: $APP_NAME
                version: "$IMAGE_TAG"
            spec:
              containers:
              - name: $APP_NAME
                image: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
                imagePullPolicy: Always
                ports:
                - containerPort: 3000
                  name: http
                env:
                - name: NODE_ENV
                  value: production
                - name: PORT
                  value: "3000"
                resources:
                  requests:
                    memory: "128Mi"
                    cpu: "125m"
                  limits:
                    memory: "512Mi"
                    cpu: "500m"
                startupProbe:
                  httpGet:
                    path: /
                    port: 3000
                  initialDelaySeconds: 10
                  periodSeconds: 5
                  timeoutSeconds: 3
                  failureThreshold: 30
                livenessProbe:
                  httpGet:
                    path: /
                    port: 3000
                  initialDelaySeconds: 60
                  periodSeconds: 10
                  timeoutSeconds: 5
                  failureThreshold: 3
                readinessProbe:
                  httpGet:
                    path: /
                    port: 3000
                  initialDelaySeconds: 5
                  periodSeconds: 5
                  timeoutSeconds: 3
                  failureThreshold: 3
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: $APP_NAME-service
          namespace: $K8S_NAMESPACE
          labels:
            app: $APP_NAME
        spec:
          selector:
            app: $APP_NAME
          ports:
          - protocol: TCP
            port: 80
            targetPort: 3000
            name: http
          type: ClusterIP
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: $APP_NAME-lb
          namespace: $K8S_NAMESPACE
          labels:
            app: $APP_NAME
          annotations:
            service.beta.kubernetes.io/aws-load-balancer-type: nlb
            service.beta.kubernetes.io/aws-load-balancer-scheme: internet-facing
        spec:
          selector:
            app: $APP_NAME
          ports:
          - protocol: TCP
            port: 80
            targetPort: 3000
            name: http
          type: LoadBalancer
        EOF

    - name: Debug deployment status
      run: |
        echo "üîç Debugging deployment status..."
        kubectl get nodes -o wide
        echo "--- Pod Status ---"
        kubectl get pods -n $K8S_NAMESPACE -l app=$APP_NAME -o wide
        echo "--- Deployment Status ---"
        kubectl describe deployment $APP_NAME -n $K8S_NAMESPACE
        echo "--- Events ---"
        kubectl get events -n $K8S_NAMESPACE --sort-by='.lastTimestamp'

    - name: Wait for deployment rollout
      run: |
        echo "‚è≥ Waiting for deployment to be ready..."
        kubectl rollout status deployment/$APP_NAME -n $K8S_NAMESPACE --timeout=900s || {
          echo "‚ùå Deployment rollout failed or timed out"
          echo "üîç Final debugging information:"
          kubectl get deployment $APP_NAME -n $K8S_NAMESPACE -o yaml
          kubectl get pods -n $K8S_NAMESPACE -l app=$APP_NAME -o yaml
          kubectl get events -n $K8S_NAMESPACE --sort-by='.lastTimestamp'
          exit 1
        }
        echo "‚úÖ Deployment rollout completed successfully"

    - name: Run application health check
      run: |
        echo "üîç Testing application health..."
        sleep 30

        LB_URL=$(kubectl get service $APP_NAME-lb -n $K8S_NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")

        if [[ -n "$LB_URL" ]]; then
          echo "üìã LoadBalancer URL: http://$LB_URL"

          for i in {1..5}; do
            echo "Attempt $i: Testing http://$LB_URL"
            if curl -f -s -o /dev/null --max-time 10 http://$LB_URL; then
              echo "‚úÖ Application is responding!"
              break
            fi
            echo "‚è≥ Waiting 30 seconds before retry..."
            sleep 30
          done
        else
          echo "‚ö†Ô∏è LoadBalancer URL not available yet"
        fi

