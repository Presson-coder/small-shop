name: CloudPilot Local Deploy - small-shop-app-demo

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: false
        default: 'local'

env:
  APP_NAME: small-shop-app-demo
  K8S_NAMESPACE: dev
  IMAGE_TAG: v1769512570689

jobs:
  local-deploy:
    name: Build and Deploy to Minikube
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Minikube
      uses: medyagh/setup-minikube@v0.0.14
      with:
        minikube-version: 1.32.0
        kubernetes-version: 1.28.3
        driver: docker
        container-runtime: docker
        start-args: '--memory=4096 --cpus=2'

    - name: Verify Minikube
      run: |
        minikube status
        kubectl cluster-info
        kubectl get nodes

    - name: Deploy PostgreSQL
      run: |
        kubectl create namespace $K8S_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: postgres
          namespace: $K8S_NAMESPACE
          labels:
            app: postgres
            managed-by: cloudpilot
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: postgres
          template:
            metadata:
              labels:
                app: postgres
            spec:
              containers:
              - name: postgres
                image: postgres:15-alpine
                env:
                              - name: POSTGRES_DB
                                value: "small_shop"
                              - name: POSTGRES_USER
                                value: "postgres"
                              - name: POSTGRES_PASSWORD
                                value: "password@123%"

                ports:
                - containerPort: 5432
                volumeMounts:
                - name: postgres-storage
                  mountPath: /var/lib/postgresql/data
                readinessProbe:
                  exec:
                    command:
                    - pg_isready
                    - -U
                    - postgres
                  initialDelaySeconds: 5
                  periodSeconds: 5
                livenessProbe:
                  exec:
                    command:
                    - pg_isready
                    - -U
                    - postgres
                  initialDelaySeconds: 30
                  periodSeconds: 10
              volumes:
              - name: postgres-storage
                emptyDir: {}
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: postgres-service
          namespace: $K8S_NAMESPACE
          labels:
            app: postgres
        spec:
          selector:
            app: postgres
          ports:
          - port: 5432
            targetPort: 5432
          type: ClusterIP
        EOF

        echo "‚è≥ Waiting for PostgreSQL to be ready..."
        kubectl wait --for=condition=ready pod -l app=postgres -n $K8S_NAMESPACE --timeout=120s

    - name: Build Docker image in Minikube
      run: |
        # Use minikube's docker daemon
        eval $(minikube docker-env)

        echo "üìã Building image with tag: $IMAGE_TAG"

        # Build directly in minikube's docker
        docker build -t $APP_NAME:$IMAGE_TAG .
        docker build -t $APP_NAME:latest .

        echo "‚úÖ Image built in Minikube Docker daemon"
        docker images | grep $APP_NAME || echo "‚ö†Ô∏è Image not found in minikube docker"

    - name: Deploy to Minikube
      run: |
        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: $APP_NAME
          namespace: $K8S_NAMESPACE
          labels:
            app: $APP_NAME
            environment: local
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: $APP_NAME
          template:
            metadata:
              labels:
                app: $APP_NAME
            spec:
              containers:
              - name: $APP_NAME
                image: $APP_NAME:$IMAGE_TAG
                imagePullPolicy: Never
                ports:
                - containerPort: 3000
                  name: http
                env:
                        - name: DATABASE_URL
                          value: "postgresql://postgres:password%40123%25@host.minikube.internal:5433/small_shop"
                        - name: PORT
                          value: "3000"

                resources:
                  requests:
                    memory: "128Mi"
                    cpu: "125m"
                  limits:
                    memory: "512Mi"
                    cpu: "500m"
                readinessProbe:
                  httpGet:
                    path: /
                    port: 3000
                  initialDelaySeconds: 30
                  periodSeconds: 10
                  timeoutSeconds: 5
                  failureThreshold: 6
                livenessProbe:
                  httpGet:
                    path: /
                    port: 3000
                  initialDelaySeconds: 60
                  periodSeconds: 10
                  timeoutSeconds: 5
                  failureThreshold: 3
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: $APP_NAME-service
          namespace: $K8S_NAMESPACE
          labels:
            app: $APP_NAME
        spec:
          selector:
            app: $APP_NAME
          ports:
          - port: 80
            targetPort: 3000
            name: http
          type: ClusterIP
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: $APP_NAME-nodeport
          namespace: $K8S_NAMESPACE
          labels:
            app: $APP_NAME
        spec:
          selector:
            app: $APP_NAME
          ports:
          - port: 3000
            targetPort: 3000
            nodePort: 30080
            name: http
          type: NodePort
        EOF

    - name: Debug deployment before waiting
      run: |
        echo "üîç Deployment created, checking initial status..."
        kubectl get deployment $APP_NAME -n $K8S_NAMESPACE
        kubectl get pods -n $K8S_NAMESPACE -l app=$APP_NAME
        kubectl get events -n $K8S_NAMESPACE --sort-by='.lastTimestamp' | tail -10

    - name: Wait for deployment with detailed monitoring
      run: |
        echo "‚è≥ Waiting for application to be ready..."

        # Wait for deployment to be available with timeout
        timeout 300 bash -c '
          while true; do
            READY_REPLICAS=$(kubectl get deployment $APP_NAME -n $K8S_NAMESPACE -o jsonpath="{.status.readyReplicas}")
            DESIRED_REPLICAS=$(kubectl get deployment $APP_NAME -n $K8S_NAMESPACE -o jsonpath="{.spec.replicas}")

            echo "üìä Deployment status: Ready=$READY_REPLICAS, Desired=$DESIRED_REPLICAS"

            if [ "$READY_REPLICAS" = "$DESIRED_REPLICAS" ] && [ "$READY_REPLICAS" != "" ]; then
              echo "‚úÖ Deployment is ready!"
              break
            fi

            echo "üìã Pod status:"
            kubectl get pods -n $K8S_NAMESPACE -l app=$APP_NAME

            echo "üìã Recent events:"
            kubectl get events -n $K8S_NAMESPACE --sort-by=".lastTimestamp" | tail -5

            sleep 10
          done
        ' || {
          echo "‚ùå Deployment failed or timed out"
          echo "üîç Final debugging information:"

          echo "--- Deployment Status ---"
          kubectl describe deployment $APP_NAME -n $K8S_NAMESPACE

          echo "--- Pod Status ---"
          kubectl get pods -n $K8S_NAMESPACE -l app=$APP_NAME -o wide
          kubectl describe pods -n $K8S_NAMESPACE -l app=$APP_NAME

          echo "--- Pod Logs ---"
          for pod in $(kubectl get pods -n $K8S_NAMESPACE -l app=$APP_NAME -o jsonpath="{.items[*].metadata.name}"); do
            echo "Logs for pod $pod:"
            kubectl logs $pod -n $K8S_NAMESPACE --tail=50
          done

          echo "--- Events ---"
          kubectl get events -n $K8S_NAMESPACE --sort-by=".lastTimestamp"

          echo "--- Docker Images ---"
          eval $(minikube docker-env)
          docker images | grep $APP_NAME

          exit 1
        }

    - name: Verify deployment health
      run: |
        echo "üè• Verifying deployment health..."

        # Check pod status
        kubectl get pods -n $K8S_NAMESPACE -l app=$APP_NAME -o wide

        # Check if pods are actually running
        POD_STATUS=$(kubectl get pods -n $K8S_NAMESPACE -l app=$APP_NAME -o jsonpath='{.items[0].status.phase}')
        echo "üìã Pod status: $POD_STATUS"

        if [ "$POD_STATUS" != "Running" ]; then
          echo "‚ö†Ô∏è Pod is not running, checking logs..."
          kubectl logs -n $K8S_NAMESPACE -l app=$APP_NAME --tail=50
        else
          echo "‚úÖ Pod is running successfully"
        fi

    - name: Test Database Connection
      run: |
        echo "üß™ Testing database connection..."

        # Get a postgres pod
        POSTGRES_POD=$(kubectl get pods -n $K8S_NAMESPACE -l app=postgres -o jsonpath='{.items[0].metadata.name}')
        echo "Testing connection to PostgreSQL pod: $POSTGRES_POD"

        # Test connection
        kubectl exec $POSTGRES_POD -n $K8S_NAMESPACE -- psql -U postgres -d small_shop -c "SELECT version();"

        echo "‚úÖ Database connection test successful"

    - name: Get service URLs
      run: |
        echo "üåê Getting service access information..."

        # Get minikube IP
        MINIKUBE_IP=$(minikube ip)
        echo "üìç Minikube IP: $MINIKUBE_IP"

        # Get NodePort
        NODE_PORT=$(kubectl get service $APP_NAME-nodeport -n $K8S_NAMESPACE -o jsonpath='{.spec.ports[0].nodePort}')
        echo "üîå NodePort: $NODE_PORT"

        echo ""
        echo "üéâ DEPLOYMENT SUCCESSFUL! üéâ"
        echo "================================"
        echo "Application: $APP_NAME"
        echo "Environment: Local Minikube"
        echo "Namespace: $K8S_NAMESPACE"
        echo ""
        echo "üìç Access URLs:"
        echo "  üåê NodePort: http://$MINIKUBE_IP:$NODE_PORT"
        echo "  üîó Service URL: $(minikube service $APP_NAME-nodeport -n $K8S_NAMESPACE --url)"
        echo ""
        echo "üóÑÔ∏è Database:"
        echo "  üìä PostgreSQL running inside Minikube"
        echo "  üîó Connection: postgres-service:5432"

    - name: Test deployment connectivity
      run: |
        # Get the service URL
        SERVICE_URL=$(minikube service $APP_NAME-nodeport -n $K8S_NAMESPACE --url)
        echo "üß™ Testing deployment at: $SERVICE_URL"

        # Wait a bit for service to be ready
        sleep 15

        # Test root endpoint with more robust checking
        echo "Testing connectivity..."
        for i in {1..5}; do
          echo "Attempt $i:"
          if curl -f -s --max-time 10 "$SERVICE_URL" > /dev/null; then
            echo "‚úÖ Root endpoint responding"
            curl -s --max-time 10 "$SERVICE_URL" | head -5
            break
          else
            echo "‚ö†Ô∏è Attempt $i failed, retrying in 10 seconds..."
            sleep 10
          fi
        done

